<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta charset="utf-8" />
  <title property="foaf:name schema:name">In-Memory Indexing of Quoted RDF Triples</title>
  <link rel="stylesheet" media="screen" href="styles/screen.css" />
  <link rel="stylesheet" media="print"  href="styles/print.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="citation_title" content="In-Memory Indexing of Quoted RDF Triples">
  <meta name="citation_author" content="Ruben Taelman" />
  <meta name="citation_author" content="Ruben Verborgh" />
  
  <meta name="citation_publication_date" content="2023/06/19" />
</head>

<body prefix="dctypes: http://purl.org/dc/dcmitype/ pimspace: http://www.w3.org/ns/pim/space# rsa: http://www.w3.org/ns/auth/rsa# cert: http://www.w3.org/ns/auth/cert# wgs: http://www.w3.org/2003/01/geo/wgs84_pos# biblio: http://purl.org/net/biblio# bibo: http://purl.org/ontology/bibo/ book: http://purl.org/NET/book/vocab# ov: http://open.vocab.org/terms/ doap: http://usefulinc.com/ns/doap# dbr: http://dbpedia.org/resource/ dbp: http://dbpedia.org/property/ sio: http://semanticscience.org/resource/ opmw: http://www.opmw.org/ontology/ deo: http://purl.org/spar/deo/ doco: http://purl.org/spar/doco/ cito: http://purl.org/spar/cito/ fabio: http://purl.org/spar/fabio/ solid: http://www.w3.org/ns/solid/terms# acl: http://www.w3.org/ns/auth/acl# dio: https://w3id.org/dio# lsc: http://linkedscience.org/lsc/ns#" typeof="schema:CreativeWork sioc:Post prov:Entity lsc:Research">
  <header>
  <h1 id="in-memory-indexing-of-quoted-rdf-triples">In-Memory Indexing of Quoted RDF Triples</h1>

  <ul id="authors">
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://www.rubensworks.net/" typeof="foaf:Person schema:Person" resource="https://www.rubensworks.net/#me">Ruben Taelman</a></li>
    <li><a rev="lsc:participatesIn" property="foaf:maker schema:creator schema:author schema:publisher" href="https://ruben.verborgh.org/" typeof="foaf:Person schema:Person" resource="https://ruben.verborgh.org/profile/#me">Ruben Verborgh</a></li>
  </ul>

  <ul id="affiliations">
    <li id="idlab">IDLab,
          Department of Electronics and Information Systems,
          Ghent University – imec
          <br />Ghent, Belgium
          <br />E-mail: ruben.taelman@ugent.be</li>
  </ul>

</header>

<!-- Hack to make our custom fonts load in print-mode -->
<!-- https://stackoverflow.com/questions/39364259/chrome-print-preview-doesnt-load-media-only-print-font-face -->
<p><span class="printfont1"> </span>
<span class="printfont2"> </span>
<span class="printfont3"> </span>
<span class="printfont4"> </span></p>

<div id="content">
  <section id="abstract" inlist="" rel="schema:hasPart" resource="#abstract">
<div datatype="rdf:HTML" property="schema:description">
      <h2 property="schema:name">Abstract</h2>
      <!-- Context      -->
      <p>The upcoming RDF 1.2 recommendation is scheduled will introduce the concept of <em>quoted triples</em>,
which allows statements to be made about other statements.
<!-- Need         -->
Since quoted triples enable new forms of data access in SPARQL 1.2, in the form of <em>quoted triple patterns</em>,
there is a need for new indexing strategies that can efficiently handle these data access patterns.
<!-- Task         -->
As such, we explore and evaluate different in-memory indexing approaches for quoted triples.
<!-- Object       -->
In this paper, we investigate four indexing approaches,
and evaluate their performance over an artificial dataset with artificial triple pattern queries.
<!-- Findings     -->
Our findings show that the so-called <em>indexed quoted triples dictionary</em> vastly outperforms other approaches
in terms of query execution time at the cost of increased storage size and ingestion time.
<!-- Conclusion   -->
Our work shows that indexing quoted triples in a dictionary separate from non-quoted RDF terms achieves good performance,
and can be implemented using well-known indexing techniques into existing systems.
<!-- Perspectives -->
Therefore, we illustrate that the addition of quoted triples into the RDF stack can be achieved in a performant manner.</p>

    </div>
</section>


<main>
  <section id="introduction" inlist="" rel="schema:hasPart" resource="#introduction">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Introduction</h2>

        <p><a property="schema:citation http://purl.org/spar/cito/cites" href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/">RDF</a> <span class="references">[<a href="#ref-1">1</a>]</span> and Labeled Property Graphs (LPGs) <span class="references">[<a href="#ref-2">2</a>]</span> have been around in recent years
as two major but diverging approaches for modeling Knowledge Graphs <span class="references">[<a href="#ref-3">3</a>]</span>.
One of the main reasons for divergence, is the fact that LPGs allow datasets to contain statements about other statements, while RDF does not.
This concept enables attaching metadata to statements, such as certainties or temporal validity.
For example, it allows one to express <em>“Alice says that Violets are Blue.”</em>,
where the statement statement about Violets being Blue is <em>quoted</em> inside a statement from Alice.</p>

        <p>In an effort to align these incompatibilities between RDF and LPGs,
the RDF<em> <span class="references">[<a href="#ref-4">4</a>]</span> approach was introduced,
which proposes an extension of the RDF data model and SPARQL query language with support for the concept of *quoted triples</em>.
This approach was picked up by a <a href="https://w3c.github.io/rdf-star/">W3C community group</a>,
and standardized in the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://www.w3.org/2021/12/rdf-star.html">RDF-star and SPARQL-star community group report</a> <span class="references">[<a href="#ref-5">5</a>]</span>.
This work is now being carried forward by the W3C RDF-star working group for standardization into the RDF 1.2 and SPARQL 1.2 recommendations.</p>

        <p>Given the wide range of practical real-world applications <span class="references">[<a href="#ref-6">6</a>, <a href="#ref-7">7</a>]</span> for quoted triples,
<a property="schema:citation http://purl.org/spar/cito/cites" href="https://w3c.github.io/rdf-star/implementations.html">many open-source and commercial RDF and SPARQL systems have already implemented parts of this approach</a> <span class="references">[<a href="#ref-8">8</a>]</span>.
Notable are systems such as BlazeGraph, GraphDB, and Stardog,
which offer the storage of quoted triples in their triplestore, and queryable access using SPARQL.
Even though some approaches offer reports of their systems passing RDF-star specification tests,
and provide high-level documentation explaining the concepts of quoted triples for end-users,
none of them offer detailed descriptions of their indexing approach,
or query performance evaluations over them.
As such, there is an open knowledge gap on the research question
<em>“How to index quoted triples, and what is the impact on ingestion, storage, and query performance?”</em>.</p>

        <p>To fill this gap, we explore four different indexing approaches,
implement them in a single system for fair comparison,
and evaluate them in terms of ingestion time, storage size, and query performance.
We focus on in-memory indexing, but approaches are generalizable to mixed disk/memory approaches such as <a property="schema:citation http://purl.org/spar/cito/cites" href="http://www.websemanticsjournal.org/index.php/ps/article/view/328">HDT</a> <span class="references">[<a href="#ref-9">9</a>]</span>.
Like many RDF indexing approaches <span class="references">[<a href="#ref-10">10</a>, <a href="#ref-11">11</a>]</span>,
we focus on providing indexed access for triple pattern queries,
as these form the basis for answering full SPARQL queries.</p>

      </div>
</section>

  <section id="related-work" inlist="" rel="schema:hasPart" resource="#related-work">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Related Work</h2>

        <p>Given the recent introduction of RDF-star and the concept of quoted triples,
scientific literature on making use of it is limited.
First, several use cases <span class="references">[<a href="#ref-6">6</a>, <a href="#ref-7">7</a>]</span> have been explored using quoted triples.
Furthermore, a declarative language called <em>RML-star</em> <span class="references">[<a href="#ref-12">12</a>]</span> has been introduced that allows
heterogeneous datasources such as CSV and JSON to be mapped into RDF datasets containing quoted triples.
This language is an extension of the RML language <span class="references">[<a href="#ref-13">13</a>]</span>,
and has been implemented in Morph-KGCstar <span class="references">[<a href="#ref-14">14</a>]</span>.
Similarly, RSP-QL* <span class="references">[<a href="#ref-15">15</a>]</span> was introduced as an extension to the
RSP-QL model <span class="references">[<a href="#ref-16">16</a>]</span> for RDF Stream Processing to support quoted triples.
Finally, two approaches <span class="references">[<a href="#ref-17">17</a>]</span> are identified to transform RDF datasets
containing quoted triples into a property graphs model <span class="references">[<a href="#ref-2">2</a>]</span>.</p>

        <p>RDF-star is seeing wide adoption among SPARQL implementations,
for which a full list of implementations that adhere to the RDF-star community group specification can be found in
<span class="references">[<a href="#ref-8">8</a>]</span>.
Unfortunately, none of these approaches clearly document their storage and indexing approach,
which motivates the need for this article on comparing various indexing techniques.</p>

      </div>
</section>

  <section id="background" inlist="" rel="schema:hasPart" resource="#background">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Background</h2>

        <p>Indexing is an important and well-understood element of RDF storage systems and SPARQL query engines,
where it provides a trade-off between query execution time, storage space, and ingestion time.
Existing approaches are either based on existing database technologies,
such as relational databases <span class="references">[<a href="#ref-18">18</a>]</span> or document stores <span class="references">[<a href="#ref-19">19</a>]</span>,
or provide native support for RDF triples.
In the context of this paper, we focus on the latter.
Furthermore, we limit our discussion to the storage of RDF triples
without considering the concept of named graphs,
as these can be considered as fourth element in a quad-like structure,
for which straightforward index extensions are possible.</p>

        <h3 id="indexes-for-different-orders">Indexes for different orders</h3>

        <p>A first important concept in RDF indexing is the <em>storage of triples in different orders</em>,
which is done by many RDF storage techniques, such as RDF-3X <span class="references">[<a href="#ref-10">10</a>]</span> and Hexastore <span class="references">[<a href="#ref-11">11</a>]</span>.
Given that a triple consists of
a subject (<code>S</code>), predicate (<code>P</code>) and object (<code>O</code>),
both systems include six indexes for different triple component orders (<code>SPO</code>, <code>SOP</code>, <code>OSP</code>, <code>OPS</code>, <code>PSO</code> and <code>POS</code>).
The presence of these indexes allows all possible triple patterns to be executed efficiently.
For example, the triple pattern query <code>??O</code> can be answered most efficiently using the <code>OSP</code> or <code>OPS</code> indexes,
while the query <code>S?O</code> could be answered using <code>SOP</code> and <code>OSP</code>.
Next to triple pattern access efficiency, these orders also enable more efficient triple pattern join processing inside query engines,
where the highly efficient sort-merge join could for example be used for joins between triple patterns if triples are sorted in the same manner.
RDF-3X goes a step further, and also provides six aggregated indexes (<code>SP</code>, <code>SO</code>, <code>PS</code>, <code>PO</code>, <code>OS</code>, and <code>OP</code>),
and three one-valued indexes (<code>S</code>, <code>P</code>, and <code>O</code>).
The triples inside each index can be stored in different ways, such as ordered lists (Hexastore) or B+Trees (RDF-3X).
Approaches such as <a property="schema:citation http://purl.org/spar/cito/cites" href="http://www.websemanticsjournal.org/index.php/ps/article/view/328">HDT</a> <span class="references">[<a href="#ref-9">9</a>]</span> and <a property="schema:citation http://purl.org/spar/cito/cites" href="https://rdfostrich.github.io/article-jws2018-ostrich/">OSTRICH</a> <span class="references">[<a href="#ref-20">20</a>]</span> go the different direction,
and store fewer indexes (<code>SPO</code>, <code>POS</code>, <code>OSP</code>) to focus purely on the triple pattern access efficiency in combination with a lower storage cost.
In the context of this article, we assume tree-like indexing,
and we refer to the triple component parts of an index as <em>triple component indexes</em>.
For example, the <code>SPO</code> index would have 3 triple component indexes: <code>S</code>, <code>P</code>, and <code>O</code>.</p>

        <h3 id="dictionary-encoding">Dictionary encoding</h3>

        <p>A second important aspect in RDF indexing is the <em>encoding of RDF terms using dictionaries</em>.
A main purpose of dictionary-encoding is the reduction in storage overhead if RDF terms are reused across multiple triples inside indexes.
The dictionary itself is a datastructure that maintains a bidirectional mapping of RDF terms to their encodings.
Instead of storing RDF terms directly inside indexes, terms are first encoded into a more compact datatype, such as an integer,
which is then stored inside the index instead.
At query time, non-variable triple pattern terms can also be encoded, and queried inside the index.
When returning query results, encoded triples can be decoded using the dictionary.</p>

        <p><a href="#figure-background-triplestore">Fig. 1</a> shows an illustration of the typical components of a triplestore.
This example store contains three indexes, with triples stored in <code>SPO</code>, <code>POS</code>, and <code>OSP</code> orders in tree-like structure.
These indexes make use of a single shared dictionary, which encodes the RDF terms inside all RDF triples stored by the indexes.</p>

        <figure id="figure-background-triplestore">
<img src="img/background-triplestore.svg" alt="[Components of a Triple Store]" />
<figcaption>
            <p><span class="label">Fig. 1:</span> The different components of a triplestore, containing one dictionary that is used by three indexes.</p>
          </figcaption>
</figure>

        <h3 id="triple-pattern-queries">Triple Pattern Queries</h3>

        <p>To simplify discussions involving triple pattern queries,
we outline a traditional high-level query execution approach for triple pattern queries
in <a href="#algorithm-triplestore-query">Algorithm 1</a>, <a href="#algorithm-triplestoreindex-query">Algorithm 2</a>, and <a href="#algorithm-triplestoreindexcomponent-query">Algorithm 3</a>.
As shown in <a href="#algorithm-triplestore-query">Algorithm 1</a>, the first step involves determining the most suitable index for a given triple pattern query.
For example, a <code>??O</code> query can be answered most efficiently using the <code>OSP</code> index.
The triple pattern query is then delegated to the index,
which is executed according to <a href="#algorithm-triplestoreindex-query">Algorithm 2</a>.
In this step, we recursively drill down into the tree-like index by iterating over all matching terms of each triple pattern component.
The algorithm for finding all matches for a single triple pattern component is shown in <a href="#algorithm-triplestoreindexcomponent-query">Algorithm 3</a>,
which either returns all terms in this part of the index if the term is a variable,
or returns the term itself if the term is inside the index if the term is not a variable.
We will replace parts of these algorithms when introducing our quoted triples indexing approaches in <a href="#approaches">Section 5</a>.</p>

        <figure id="algorithm-triplestore-query" class="algorithm">
<pre><code>FUNCTION QueryStore(store, tp)
</code><code>  INPUT:
</code><code>    store: triple store
</code><code>    tp: triple pattern
</code><code>  OUTPUT:
</code><code>    ts: sequence of triples
</code><code>idx = most suitable index from store.indexes
</code><code>ts = QueryTriplePatternIndex(idx, store.dict, tp)
</code><code>RETURN ts</code></pre>
<figcaption>
            <p><span class="label">Algorithm 1:</span> Pseudocode for executing a triple pattern query over a triplestore containing one or more indexes.</p>
          </figcaption>
</figure>

        <figure id="algorithm-triplestoreindex-query" class="algorithm">
<pre><code>FUNCTION QueryIndex(idx, dict, tp)
</code><code>  INPUT:
</code><code>    idx: triple pattern index
</code><code>    dict: dictionary
</code><code>    tp: triple pattern
</code><code>  OUTPUT:
</code><code>    ts: sequence of triples
</code><code>tpe = dict.encode(tp);
</code><code>FOR subject IN QueryIndexComponent(idx, dict, tpe.subject])
</code><code>  indx_s = idx[subject]
</code><code>  FOR predicate IN QueryIndexComponent(indx_s, dict, tpe.predicate])
</code><code>    indx_p = indx_s[predicate]
</code><code>    FOR object IN QueryIndexComponent(indx_p, dict, tpe.object])
</code><code>      object = indx_p[object]
</code><code>      ts.push(subject, predicate, object)
</code><code>    END
</code><code>  END
</code><code>END
</code><code>ts = 
</code><code>RETURN ts</code></pre>
<figcaption>
            <p><span class="label">Algorithm 2:</span> Pseudocode for executing a triple pattern query over an index, sorted in <code>SPO</code> order.</p>
          </figcaption>
</figure>

        <figure id="algorithm-triplestoreindexcomponent-query" class="algorithm">
<pre><code>FUNCTION QueryIndexComponent(idxc, dict, term)
</code><code>  INPUT:
</code><code>    idxc: a certain triple component of a triple index
</code><code>    dict: dictionary
</code><code>    term: a term inside a triple pattern
</code><code>  OUTPUT:
</code><code>    ts: sequence of triples
</code><code>matchingTerms = []
</code><code>IF term.type === &#39;Variable&#39;
</code><code>  FOR key IN idxc
</code><code>    matchingTerms.push(dict.decode(key))
</code><code>  END
</code><code>ELSE
</code><code>  IF idxc contains dict.encode(term)
</code><code>    matchingTerms.push(term)
</code><code>  END
</code><code>END
</code><code>RETURN matchingTerms</code></pre>
<figcaption>
            <p><span class="label">Algorithm 3:</span> Pseudocode for finding all matches of a single triple component inside an index.</p>
          </figcaption>
</figure>

      </div>
</section>

  <section id="use-case" inlist="" rel="schema:hasPart" resource="#use-case">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Use Case</h2>

        <p>As example use case to illustrate different indexing approaches,
we introduce a fictional dataset containing statements from different people
on the color of violets in <a href="#usecase-dataset">Listing 1</a>.</p>

        <figure id="usecase-dataset" class="listing">
<pre><code>@prefix : &lt;http://example.org/foo#&gt; .
</code><code>:Alice :says &lt;&lt; :Violets :haveColor :Blue   &gt;&gt; .
</code><code>:Bob   :says &lt;&lt; :Violets :haveColor :Yellow &gt;&gt; .
</code></pre>
<figcaption>
            <p><span class="label">Listing 1:</span> Turtle snippets containing statements by Alice and Bob on the color of violets.</p>
          </figcaption>
</figure>

        <p>To find out what color each person says violets have,
we can execute the SPARQL query from <a href="#usecase-query">Listing 2</a>.
This query contains a variable in the subject position,
and a variable inside the quoted triple pattern of the object position.
For brevity in the remainder of this article, we refer to the variables inside quoted triple patterns as <em>quoted variables</em>.</p>

        <figure id="usecase-query" class="listing">
<pre><code>PREFIX : &lt;http://example.org/foo#&gt;
</code><code>SELECT ?person ?color WHERE {
</code><code>  ?person :says &lt;&lt; :Violets :haveColor ?color &gt;&gt; .
</code><code>}
</code></pre>
<figcaption>
            <p><span class="label">Listing 2:</span> SPARQL query to find what color each person says violets have.</p>
          </figcaption>
</figure>

      </div>
</section>

  <section id="approaches" inlist="" rel="schema:hasPart" resource="#approaches">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Indexing Approaches</h2>

        <p>In this section, we introduce four approaches for indexing quoted triples,
with increasing levels of complexity.
These approaches build upon the well-established methods of
using dictionary encoding
and storing triples in different orders
as explained in <a href="#background">Section 3</a>.
Our approaches only rely on changes within the dictionary mechanism,
while the triple index itself can remain unchanged.</p>

        <h3 id="singular-dictionary">Singular Dictionary</h3>

        <p>A straightforward way to achieve dictionary encoding of quoted triples,
is to include quoted triples directly inside the dictionary with all other RDF terms.
As such, quoted triples are handled in exactly the same manner as other RDF term types.
For dictionaries that map strings to integers, this requires a mechanism to convert quoted triples into strings.
<a href="#figure-dict-singular">Fig. 2</a> shows an example of such dictionary contents based on our use case data.</p>

        <figure id="figure-dict-singular">
<img src="img/dict-singular.svg" alt="[Singular Dictionary]" style="width: 50%" />
<figcaption>
            <p><span class="label">Fig. 2:</span> Plain terms and quoted triples are stored inside the same dictionary.</p>
          </figcaption>
</figure>

        <p>Executing triple pattern queries is identical to the baseline approach as explain in <a href="#background">Section 3</a>,
except for triple patterns containing quoted variables, such as the query <code>?person :says &lt;&lt;Violets haveColor ?color&gt;&gt;</code>.
As this approach has no direct way of matching the <code>?color</code> variable to quoted triples,
we are required to convert quoted triple pattern terms containing variables to variables,
and perform a post-processing step to only emit those triples that match the quoted triple pattern.
The pseudo-code of this algorithm is shown in <a href="#algorithm-query-dict-singular">Algorithm 4</a>.</p>

        <figure id="algorithm-query-dict-singular" class="algorithm">
<pre><code>FUNCTION QueryIndexSingularDict(idx, dict, tp)
</code><code>  INPUT:
</code><code>    idx: triple pattern index
</code><code>    dict: singular dictionary
</code><code>    tp: triple pattern
</code><code>  OUTPUT:
</code><code>    ts: sequence of triples
</code><code>IF tp.subject.type === &#39;Quoted&#39; &amp;&amp; tp.subject contains variables
</code><code>  s_filter = tp.subject
</code><code>  tp.subject = new Variable()
</code><code>IF tp.predicate.type === &#39;Quoted&#39; &amp;&amp; tp.predicate contains variables
</code><code>  p_filter = tp.predicate
</code><code>  tp.predicate = new Variable()
</code><code>IF tp.object.type === &#39;Quoted&#39; &amp;&amp; tp.object contains variables
</code><code>  o_filter = tp.object
</code><code>  tp.object = new Variable()
</code><code>ts = QueryIndex(idx, dict, tp);
</code><code>ts = ts.filter(t =&gt;
</code><code>  (s_filter === undefined || s_filter matches t.subject) &amp;&amp;
</code><code>  (p_filter === undefined || p_filter matches t.predicate) &amp;&amp;
</code><code>  (o_filter === undefined || o_filter matches t.object)
</code><code>)
</code><code>RETURN ts</code></pre>
<figcaption>
            <p><span class="label">Algorithm 4:</span> Pseudocode of the algorithm for executing triple pattern queries using a singular dictionary.
This algorithm is a variant of <code>QueryIndex</code> from <a href="#algorithm-triplestoreindex-query">Algorithm 2</a>.</p>
          </figcaption>
</figure>

        <p>The main advantage of this approach lies in its simplicity of implementation.
However, we hypothesize two main disadvantages:</p>

        <ol>
          <li><strong>Storage overhead</strong>: Quoted triples with shared terms lead to a storage overhead, such as the duplicate storage of <code>:Violets</code> and <code>:haveColor</code> in <a href="#figure-dict-singular">Fig. 2</a>.</li>
          <li><strong>Slow quoted triple pattern execution</strong>: When executing triple pattern queries with quoted variables, there is no indexed access to matching quoted triples, which can lead to query performance issues.</li>
        </ol>

        <h3 id="quoted-triples-dictionary">Quoted Triples Dictionary</h3>

        <p>In an attempt to cope with the two disadvantages of the singular dictionary approach,
we can dedicate the storage of quoted triples to a separate dictionary,
as shown in <a href="#figure-dict-quoted">Fig. 3</a>.</p>

        <figure id="figure-dict-quoted">
<img src="img/dict-quoted.svg" alt="[Quoted Triples Dictionary]" />
<figcaption>
            <p><span class="label">Fig. 3:</span> Plain terms and quoted triples are stored in separate dictionaries.</p>
          </figcaption>
</figure>

        <p>To execute triple pattern queries in this approach, the post-processing step from the singular dictionary is not needed anymore.
Instead, we can hook directly into the internal processing of separate triple component indexes.
Concretely, when finding all matches of a given term inside a triple component index,
we check if our term is a quoted triple pattern.
If so, we perform an inner join between all quoted triple entries within the quoted triples dictionary,
and the terms within the triple component index.
If the triple component index is index in a hash-like manner, then this inner join can be done efficiently in a hash join manner.
The pseudo-code of this algorithm is shown in <a href="#algorithm-query-dict-quoted">Algorithm 5</a>.</p>

        <figure id="algorithm-query-dict-quoted" class="algorithm">
<pre><code>FUNCTION QueryIndexComponentQuotedDict(idxc, dict, term)
</code><code>  INPUT:
</code><code>    idxc: a certain triple component of a triple index
</code><code>    dict: quoted triples dictionary
</code><code>    term: a term inside a triple pattern
</code><code>IF term.type === &#39;Quoted&#39; &amp;&amp; term contains variables
</code><code>  matchingTerms = []
</code><code>  FOR quotedTriple IN dict.getAllQuotedTriples()
</code><code>    IF idxc contains dict.encode(quotedTriple)
</code><code>      matchingTerms.push(quotedTriple)
</code><code>    END
</code><code>  RETURN matchingTerms
</code><code>ELSE
</code><code>  RETURN QueryIndexComponent(idxc, dict, term)
</code><code>END
</code><code>
</code></pre>
<figcaption>
            <p><span class="label">Algorithm 5:</span> Pseudocode of the algorithm for finding all matching terms of a certain triple component inside an index using a quoted triples dictionary.
This algorithm is a variant of <code>QueryIndexComponent</code> from <a href="#algorithm-triplestoreindexcomponent-query">Algorithm 3</a>.</p>
          </figcaption>
</figure>

        <p>We hypothesize that this separated quoted triples dictionary will result in a lower storage overhead.
Furthermore, we expect triple pattern execution to be faster due to the fact that a quoted triple pattern
will only lead to matches with entries in the quoted triples dictionary,
as opposed to <em>all</em> possible terms.
However, as shown in <a href="#figure-dict-quoted">Fig. 3</a>, this approach can still lead to redundant storage
if terms are shared across different quoted triples, such as <code>:Violet</code> and <code>:haveColor</code>.
Furthermore, the join inside the triple component index using all quoted triples
might become too expensive if there are many non-matching quoted triples.</p>

        <h3 id="referential-quoted-triples-dictionary">Referential Quoted Triples Dictionary</h3>

        <p>To solve the redundant storage issue within the quoted triples dictionary approach,
we extend upon that approach by not storing quoted triples in full,
but by instead encoding the three components of that quoted triples,
and using those encodings as key inside the dictionary.
<a href="#figure-dict-quoted-referential">Fig. 4</a> illustrates an example of this approach.</p>

        <figure id="figure-dict-quoted-referential">
<img src="img/dict-quoted-referential.svg" alt="[Referential Quoted Triples Dictionary]" />
<figcaption>
            <p><span class="label">Fig. 4:</span> Plain terms and quoted triples are stored in separate dictionaries,
where quoted triples are recursively encoded using existing dictionary encodings.</p>
          </figcaption>
</figure>

        <p>The triple pattern query algorithm is identical to the one from <a href="#algorithm-query-dict-quoted">Algorithm 5</a>,
except for the fact that dictionary encoding and decoding will require the extra step of
encoding and decoding of the three triple components.</p>

        <p>We hypothesize that this approach will lead to lower storage usage
due to the shared encoding of redundant terms inside quoted triples.</p>

        <h3 id="indexed-quoted-triples-dictionary">Indexed Quoted Triples Dictionary</h3>

        <p>The Quoted Triples Dictionary approach requires triple component indexes to join with all quoted triples,
which may be costly for selective quoted triple patterns in the presence of many non-matching quoted triples.
To solve this problem, we can modify the storage of our Quoted Triples Dictionary
from a map-like structure to a tree-like structure,
so that triple pattern matching can be done more efficiently.
Concretely, this tree-like structure can be implemented similar to a triple index,
but it must map to integer encodings of quoted triples.
<a href="#figure-dict-quoted-referential-indexed"></a> illustrates an example of this approach.
This example only makes use of the <code>SPO</code> order for encodings,
but in practise multiple other collation orders may be used.</p>

        <figure id="figure-dict-quoted-indexed">
<img src="img/dict-quoted-indexed.svg" alt="[Indexed Quoted Triples Dictionary]" />
<figcaption>
            <p><span class="label">Fig. 5:</span> Plain terms and quoted triples are stored in separate dictionaries,
where quoted triples are recursively encoded using existing dictionary encodings,
and indexed in a tree structure based on triple components.</p>
          </figcaption>
</figure>

        <p>Executing triple pattern queries is very similar to the approach of the Quoted Triples Dictionary,
with the difference that instead of joining with <em>all</em> quoted triples,
we join with only those quoted triples that match with the current quoted triple pattern.
The pseudo-code of this algorithm is shown in <a href="#algorithm-query-dict-quoted-indexed"></a>.</p>

        <figure id="algorithm-query-dict-quoted-index" class="algorithm">
<pre><code>FUNCTION QueryIndexComponentQuotedDictIndex(idxc, dict, term)
</code><code>  INPUT:
</code><code>    idxc: a certain triple component of a triple index
</code><code>    dict: quoted triples dictionary
</code><code>    term: a term inside a triple pattern
</code><code>IF term.type === &#39;Quoted&#39; &amp;&amp; term contains variables
</code><code>  matchingTerms = []
</code><code>  FOR quotedTriple IN dict.getMatchingQuotedTriples(term)
</code><code>    IF idxc contains dict.encode(quotedTriple)
</code><code>      matchingTerms.push(quotedTriple)
</code><code>    END
</code><code>  END
</code><code>  RETURN matchingTerms
</code><code>ELSE
</code><code>  RETURN QueryIndexComponent(idxc, dict, term)
</code><code>END</code></pre>
<figcaption>
            <p><span class="label">Algorithm 6:</span> Pseudocode of the algorithm for finding all matching terms of a certain triple component inside an index using an indexed quoted triples dictionary.
This algorithm is a variant of <code>QueryIndexComponent</code> from <a href="#algorithm-triplestoreindexcomponent-query">Algorithm 3</a>.</p>
          </figcaption>
</figure>

        <p>We hypothesize that this approach will speed up triple pattern query performance
due to the higher selectivity during joins between the quoted triples dictionary and the current component index.</p>

      </div>
</section>

  <section id="evaluation" inlist="" rel="schema:hasPart" resource="#evaluation">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Evaluation</h2>

        <p>In this section, we evaluate the impact of the indexing approaches discussed in <a href="#approaches">Section 5</a>
in terms of storage size, ingestion time, and query execution time.
We start by discussing our implementation of the approaches,
followed by our experimental setup, results,
and end with a discussion.</p>

        <h3 id="implementation">Implementation</h3>

        <p>To achieve a fair comparison between the different indexing approaches,
we have implemented all approaches in the same programming language (TypeScript/JavaScript).
The implementation of these approaches is open-source,
and is available on GitHub at <a href="https://github.com/rubensworks/rdf-stores.js">https:/​/​github.com/rubensworks/rdf-stores.js</a>.</p>

        <h3 id="experimental-setup">Experimental Setup</h3>

        <p>To measure the performance impact of different quoted triple depths,
we create synthetic datasets at various sizes.
Our dataset generator is based on the data model of <a href="#use-case">Section 4</a> with different people (size / 10) and colors (10),
and allows any number of triples to be generated.
Furthermore, it allows a <em>depth</em> parameter to be specified, which defines the number of quoted triples in object positions.
For instance, a depth value of 1 generates quoted triples in the form of <code>?person :says &lt;&lt; :Violets :haveColor ?color &gt;&gt;</code>,
while a depth value of 3 generated quoted triples in the form of <code>?person :says &lt;&lt; ?person :says &lt;&lt; ?person :says &lt;&lt; :Violets :haveColor ?color &gt;&gt; &gt;&gt; &gt;&gt;</code>.</p>

        <p>For our experiments, we range the dataset from 1.000 to 1.000.000,
with the depth ranging from 1 to 5.
For each combination, we measure the performance of the four indexing approaches in terms of the following metrics:</p>

        <ul>
          <li><strong>Storage size</strong>: The total memory consumption after ingestion in MB.</li>
          <li><strong>Ingestion time</strong>: The duration of ingesting the generated triples in milliseconds.</li>
          <li><strong>Query execution time</strong>: The total duration of executing all triple pattern queries in milliseconds.</li>
        </ul>

        <p>Query execution time was measured using 3 categories of queries (examples assume depth 2):</p>

        <ul>
          <li><strong>Low selectivity</strong>: Query people in the form of: <code>?person :says &lt;&lt; ?person :says &lt;&lt; :Violets :haveColor :Red &gt;&gt; &gt;&gt;</code>. Each query produces size / 10 results.</li>
          <li><strong>Medium selectivity</strong>: Query colors in the form of: <code>?person :says &lt;&lt; :Bob :says &lt;&lt; :Violets :haveColor ?color &gt;&gt; &gt;&gt;</code>. Each query produces 10 results.</li>
          <li><strong>High selectivity</strong>: Query colors of specific people in the form of: <code>:Alice :says &lt;&lt; :Bob :says &lt;&lt; :Violets :haveColor ?color &gt;&gt; &gt;&gt;</code>. Each query produces 1 results.</li>
        </ul>

        <p>The four indexing approaches were configured with three indexes (<code>SPO</code>, <code>POS</code>, <code>OSP</code>),
and the indexed quoted triples dictionary was also configured with these three indexes.
All experiments were executed on a MacBook Pro 13-inch, 2020 with 16GB or RAM and a 2,3 GHz Quad-Core Intel Core i7 processor.
Our experimental setup is fully reproducible, and is available together with the raw results at
<a href="https://github.com/rubensworks/experiments-indexing-quoted-triples">https:/​/​github.com/rubensworks/experiments-indexing-quoted-triples</a>.</p>

        <h3 id="results">Results</h3>

        <p><a href="#figure-results-ingest-size">Fig. 6</a> and <a href="#figure-results-ingest-time">Fig. 7</a> respectively show the storage sizes and ingestion times
for the different indexing approaches.
<a href="#figure-results-query-low">Fig. 8</a>, <a href="#figure-results-query-med">Fig. 9</a>, and <a href="#figure-results-query-high">Fig. 10</a>
respectively show the query execution times for low, medium, and high selectivity queries.
We omit results for quoted triple depths that do not provide additional insights aside from the highest and lowest values.
To show an overview of all storage sizes, all figures are logarithmic in both axes.</p>

        <figure id="figure-results-ingest-size" class="results-sidebyside">

<figure id="figure-results-ingest-size-1" class="subfigure">
<img src="img/experiments/results-ingest-size-1.svg" alt="Storage sizes depth 1" />
<figcaption class="for-subfigure">
              <p><span class="label">Subfig. 6.1:</span> Depth 1</p>
            </figcaption>
</figure>

<figure id="figure-results-ingest-size-5" class="subfigure">
<img src="img/experiments/results-ingest-size-5.svg" alt="Storage sizes depth 5" />
<figcaption class="for-subfigure">
              <p><span class="label">Subfig. 6.2:</span> Depth 5</p>
            </figcaption>
</figure>

<figcaption>
            <p><span class="label">Fig. 6:</span> Storage sizes for the 4 indexing approaches with increasing dataset sizes.</p>
          </figcaption>
</figure>

        <figure id="figure-results-ingest-time" class="results-sidebyside">

<figure id="figure-results-ingest-time-1" class="subfigure">
<img src="img/experiments/results-ingest-time-1.svg" alt="Ingestion times depth 1" />
<figcaption class="for-subfigure">
              <p><span class="label">Subfig. 7.1:</span> Depth 1</p>
            </figcaption>
</figure>

<figure id="figure-results-ingest-time-5" class="subfigure">
<img src="img/experiments/results-ingest-time-5.svg" alt="Ingestion times depth 5" />
<figcaption class="for-subfigure">
              <p><span class="label">Subfig. 7.2:</span> Depth 5</p>
            </figcaption>
</figure>

<figcaption>
            <p><span class="label">Fig. 7:</span> Ingestion times for the 4 indexing approaches with increasing dataset sizes.</p>
          </figcaption>
</figure>

        <figure id="figure-results-query-low" class="results-sidebyside">

<figure id="figure-results-query-low-1" class="subfigure">
<img src="img/experiments/results-query-low-1.svg" alt="Query times depth 1" />
<figcaption class="for-subfigure">
              <p><span class="label">Subfig. 8.1:</span> Depth 1</p>
            </figcaption>
</figure>

<figure id="figure-results-query-low-3" class="subfigure">
<img src="img/experiments/results-query-low-3.svg" alt="Query times depth 3" />
<figcaption class="for-subfigure">
              <p><span class="label">Subfig. 8.2:</span> Depth 3</p>
            </figcaption>
</figure>

<figure id="figure-results-query-low-4" class="subfigure">
<img src="img/experiments/results-query-low-4.svg" alt="Query times depth 4" />
<figcaption class="for-subfigure">
              <p><span class="label">Subfig. 8.3:</span> Depth 4</p>
            </figcaption>
</figure>

<figure id="figure-results-query-low-5" class="subfigure">
<img src="img/experiments/results-query-low-5.svg" alt="Query times depth 5" />
<figcaption class="for-subfigure">
              <p><span class="label">Subfig. 8.4:</span> Depth 5</p>
            </figcaption>
</figure>

<figcaption>
            <p><span class="label">Fig. 8:</span> Query execution times for the 4 indexing approaches with increasing dataset sizes with low result selectivity.</p>
          </figcaption>
</figure>

        <figure id="figure-results-query-med" class="results-sidebyside">

<figure id="figure-results-query-med-1" class="subfigure">
<img src="img/experiments/results-query-med-1.svg" alt="Query times depth 1" />
<figcaption class="for-subfigure">
              <p><span class="label">Subfig. 9.1:</span> Depth 1</p>
            </figcaption>
</figure>

<figure id="figure-results-query-med-3" class="subfigure">
<img src="img/experiments/results-query-med-3.svg" alt="Query times depth 3" />
<figcaption class="for-subfigure">
              <p><span class="label">Subfig. 9.2:</span> Depth 3</p>
            </figcaption>
</figure>

<figure id="figure-results-query-med-4" class="subfigure">
<img src="img/experiments/results-query-med-4.svg" alt="Query times depth 4" />
<figcaption class="for-subfigure">
              <p><span class="label">Subfig. 9.3:</span> Depth 4</p>
            </figcaption>
</figure>

<figure id="figure-results-query-med-5" class="subfigure">
<img src="img/experiments/results-query-med-5.svg" alt="Query times depth 5" />
<figcaption class="for-subfigure">
              <p><span class="label">Subfig. 9.4:</span> Depth 5</p>
            </figcaption>
</figure>

<figcaption>
            <p><span class="label">Fig. 9:</span> Query execution times for the 4 indexing approaches with increasing dataset sizes with medium result selectivity.</p>
          </figcaption>
</figure>

        <figure id="figure-results-query-high" class="results-sidebyside">

<figure id="figure-results-query-high-1" class="subfigure">
<img src="img/experiments/results-query-high-1.svg" alt="Query times depth 1" />
<figcaption class="for-subfigure">
              <p><span class="label">Subfig. 10.1:</span> Depth 1</p>
            </figcaption>
</figure>

<figure id="figure-results-query-high-3" class="subfigure">
<img src="img/experiments/results-query-high-3.svg" alt="Query times depth 3" />
<figcaption class="for-subfigure">
              <p><span class="label">Subfig. 10.2:</span> Depth 3</p>
            </figcaption>
</figure>

<figure id="figure-results-query-high-4" class="subfigure">
<img src="img/experiments/results-query-high-4.svg" alt="Query times depth 4" />
<figcaption class="for-subfigure">
              <p><span class="label">Subfig. 10.3:</span> Depth 4</p>
            </figcaption>
</figure>

<figure id="figure-results-query-high-5" class="subfigure">
<img src="img/experiments/results-query-high-5.svg" alt="Query times depth 5" />
<figcaption class="for-subfigure">
              <p><span class="label">Subfig. 10.4:</span> Depth 5</p>
            </figcaption>
</figure>

<figcaption>
            <p><span class="label">Fig. 10:</span> Query execution times for the 4 indexing approaches with increasing dataset sizes with high result selectivity.</p>
          </figcaption>
</figure>

        <h3 id="discussion">Discussion</h3>

        <h4 id="storage-size">Storage size</h4>

        <p>The results from <a href="#figure-results-ingest-size">Fig. 6</a> show that in terms of storage size,
the singular dictionary and referential quoted triples dictionary approaches perform the best.
The quoted triples dictionary and indexed quoted triples dictionary approaches on the other hand require significantly more memory.
Contrary to what we hypothesized in <a href="#approaches">Section 5</a>, the storage overhead of the singular dictionary for terms inside quoted triples
is less significant than expected, and the gains from the removal of storage redundancy with the referential quoted triples dictionary are minimal.
The indexed quoted triples dictionary approach results in a significantly higher storage size due to the three indexes that are used to index quoted triples.</p>

        <h4 id="ingestion-time">Ingestion time</h4>

        <p>As expected, we observe similar results in terms of ingestion time in <a href="#figure-results-ingest-time">Fig. 7</a>,
where the singular dictionary and quoted triples dictionary are significantly faster than the referential and indexed quoted triples dictionary approaches.
These approaches are faster due to their simpler encoding approach,
whereas the referential and indexed quoted triples dictionary approaches require more operations during triple encoding.</p>

        <h4 id="query-execution-time">Query execution time</h4>

        <p>The results in <a href="#figure-results-query-low">Fig. 8</a>, <a href="#figure-results-query-med">Fig. 9</a>, and <a href="#figure-results-query-high">Fig. 10</a>
show that on average, the indexed quoted triples dictionary approach vastly outperforms all other approaches.
This is most significant for triple patterns with medium selectivity due to the fact that this approach
has indexes corresponding exactly to these queries, while the other approaches require iteration over all quoted triples.
For triple patterns with low selectivity, the difference is smaller, but the indexed quoted triples dictionary approach is still faster overall.
The difference for triple patterns with high selectivity is minimal,
as the overhead of triple pattern dictionary encoding during query execution
when fetching a single result becomes more apparent.</p>

      </div>
</section>

  <section id="conclusions" inlist="" rel="schema:hasPart" resource="#conclusions">
<div datatype="rdf:HTML" property="schema:description">
        <h2 property="schema:name">Conclusions</h2>

        <p>In this article, we discussed four approaches for the in-memory indexing of quoted triples,
ranging from very naive to highly optimized for quoted triple pattern access.</p>

        <p>Our results show that the indexed quoted triples dictionary approach is orders of magnitude faster than other indexing approaches.
In the most extreme case, this approach is over 4.000 to 11.000 times faster than other indexing approaches
for a dataset size of 1 million with quoted triples at depth 5.
For smaller dataset sizes, lower quoted triple depths, and other types of queries, the difference becomes smaller.
This significant speedup at query time comes with the expected cost of increased storage size and ingestion time,
which is approximately two-fold for a large dataset.</p>

        <p>As such, for use cases where quoted triple pattern queries occur at various depths,
and an increase in storage size and ingestion time are acceptable,
the indexed quoted triples dictionary approach is highly beneficial for achieving good query performance.
Furthermore, given the fact that this approach stores quoted triple terms separate from all other terms inside the dictionary,
there is no significant overhead of using such a dictionary by default in triplestores,
even if is unknown before ingestion starts if quoted triples are present in the datasets.</p>

        <p>In future work, there is a need to evaluate the performance of different indexing approaches over real-world data,
as we only evaluated performance over artifically generated datasets, which do not capture real-world properties <span class="references">[<a href="#ref-21">21</a>]</span>.
Furthermore, we wish to evaluate the performance of these indexes within full SPARQL queries
by plugging them into <a property="schema:citation http://purl.org/spar/cito/cites" href="https://comunica.github.io/Article-ISWC2018-Resource/">a SPARQL query engine</a> <span class="references">[<a href="#ref-22">22</a>]</span>.</p>

        <p>In conclusion, the outcomes of this work show that the inclusion of the concept of quoted triples into the RDF and SPARQL recommendations
necessitates changes in triplestores in terms of indexing and dictionary encoding,
but that approaches such as the indexed quoted triples dictionary are able to provide very good performance,
while not requiring overly complicated additions implementation-wise.</p>

      </div>
</section>

</main>

<footer><section>
<h2 id="references">References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd resource="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/" typeof="schema:CreativeWork">Cyganiak, R., Wood, D., Lanthaler, M.: \rdf 1.1: Concepts and Abstract Syntax. W3C, <a href="http://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/">http:/​/​www.w3.org/TR/2014/REC-rdf11-concepts-20140225/</a> (2014).</dd>
  <dt id="ref-2">[2]</dt>
  <dd resource="#propertygraphs" typeof="schema:Article">Rodriguez, M.A., Neubauer, P.: Constructions from dots and lines. arXiv preprint arXiv:1006.2361. (2010).</dd>
  <dt id="ref-3">[3]</dt>
  <dd resource="#knowledgegraphs" typeof="schema:Article">Hogan, A., Blomqvist, E., Cochez, M., d’Amato, C., Melo, G.de, Gutierrez, C., Kirrane, S., Gayo, J.E.L., Navigli, R., Neumaier, S., others: Knowledge graphs. ACM Computing Surveys (CSUR). 54, 1–37 (2021).</dd>
  <dt id="ref-4">[4]</dt>
  <dd resource="#rdfstar" typeof="schema:Article">Hartig, O.: Foundations of RDF* and SPARQL*:(An alternative approach to statement-level metadata in RDF). In: AMW 2017 11th Alberto Mendelzon International Workshop on Foundations of Data Management and the Web, Montevideo, Uruguay, June 7-9, 2017. Juan Reutter, Divesh Srivastava (2017).</dd>
  <dt id="ref-5">[5]</dt>
  <dd resource="https://www.w3.org/2021/12/rdf-star.html" typeof="schema:CreativeWork">\RDF-star and SPARQL-star. W3C, <a href="https://www.w3.org/2021/12/rdf-star.html">https:/​/​www.w3.org/2021/12/rdf-star.html</a> (2021).</dd>
  <dt id="ref-6">[6]</dt>
  <dd resource="#kasenchak2021use" typeof="schema:Article">Kasenchak, B., Lehnert, A., Loh, G.: Use case: ontologies and RDF-star for knowledge management. In: The Semantic Web: ESWC 2021 Satellite Events: Virtual Event, June 6–10, 2021, Revised Selected Papers 18. pp. 254–260. Springer (2021).</dd>
  <dt id="ref-7">[7]</dt>
  <dd resource="#solidsignedrdfstar" typeof="schema:Chapter">Braun, C.H.-J., Käfer, T.: Self-verifying Web Resource Representations Using Solid, RDF-Star and Signed URIs. In: The Semantic Web: ESWC 2022 Satellite Events: Hersonissos, Crete, Greece, May 29–June 2, 2022, Proceedings. pp. 138–142. Springer (2022).</dd>
  <dt id="ref-8">[8]</dt>
  <dd resource="https://w3c.github.io/rdf-star/implementations.html" typeof="schema:CreativeWork">Group, R.D.F.-star W.C.C.: RDF-star Implementations. <a href="https://w3c.github.io/rdf-star/implementations.html">https:/​/​w3c.github.io/rdf-star/implementations.html</a> (2023).</dd>
  <dt id="ref-9">[9]</dt>
  <dd resource="http://www.websemanticsjournal.org/index.php/ps/article/view/328" typeof="schema:Article">Fernández, J.D., Martínez-Prieto, M.A., Gutiérrez, C., Polleres, A., Arias, M.: Binary RDF Representation for Publication and Exchange (HDT). Web Semantics: Science, Services and Agents on the World Wide Web. 19, 22–41 (2013).</dd>
  <dt id="ref-10">[10]</dt>
  <dd resource="#rdf3x" typeof="schema:Article">Neumann, T., Weikum, G.: RDF-3X: a RISC-style engine for RDF. Proceedings of the VLDB Endowment. 1, 647–659 (2008).</dd>
  <dt id="ref-11">[11]</dt>
  <dd resource="#hexastore" typeof="schema:Article">Weiss, C., Karras, P., Bernstein, A.: Hexastore: sextuple indexing for semantic web data management. Proceedings of the VLDB Endowment. 1, 1008–1019 (2008).</dd>
  <dt id="ref-12">[12]</dt>
  <dd resource="#rmlstar" typeof="schema:Article">Delva, T., Arenas-Guerrero, J., Iglesias-Molina, A., Corcho, O., Chaves-Fraga, D., Dimou, A.: RML-star: A declarative mapping language for RDF-star generation. In: ISWC2021, the International Semantic Web Conference. CEUR (2021).</dd>
  <dt id="ref-13">[13]</dt>
  <dd resource="#rml" typeof="schema:Article">Dimou, A., Vander Sande, M., Colpaert, P., Verborgh, R., Mannens, E., Van de Walle, R.: RML: A generic language for integrated RDF mappings of heterogeneous data. Ldow. 1184, (2014).</dd>
  <dt id="ref-14">[14]</dt>
  <dd resource="#morphkgcstar" typeof="schema:Article">Arenas-Guerrero, J., Iglesias-Molina, A., Chaves-Fraga, D., Garijo, D., Corcho, O., Dimou, A.: Morph-KGCstar: Declarative generation of RDF-star graphs from heterogeneous data. Semantic Web (Under Review). (2023).</dd>
  <dt id="ref-15">[15]</dt>
  <dd resource="#rspqlstar" typeof="schema:Article">Keskisärkkä, R., Blomqvist, E., Lind, L., Hartig, O.: RSP-QL: Enabling Statement-Level Annotations in RDF Streams. In: Semantic Systems. The Power of AI and Knowledge Graphs: 15th International Conference, SEMANTiCS 2019, Karlsruhe, Germany, September 9–12, 2019, Proceedings. pp. 140–155. Springer (2019).</dd>
  <dt id="ref-16">[16]</dt>
  <dd resource="#rspql" typeof="schema:Article">Dell’Aglio, D., Della Valle, E., Calbimonte, J.-P., Corcho, O.: RSP-QL semantics: A unifying query model to explain heterogeneity of RDF stream processing systems. International Journal on Semantic Web and Information Systems (IJSWIS). 10, 17–44 (2014).</dd>
  <dt id="ref-17">[17]</dt>
  <dd resource="#transformingrdfstarpropgraphs" typeof="schema:Article">Abuoda, G., Dell’Aglio, D., Keen, A., Hose, K.: Transforming RDF-star to Property Graphs: A Preliminary Analysis of Transformation Approaches–extended version. arXiv preprint arXiv:2210.05781. (2022).</dd>
  <dt id="ref-18">[18]</dt>
  <dd resource="#virtuoso" typeof="schema:Chapter">Erling, O., Mikhailov, I.: Virtuoso: RDF support in a native RDBMS. In: Semantic Web Information Management. pp. 501–519. Springer (2010).</dd>
  <dt id="ref-19">[19]</dt>
  <dd resource="#dsparq" typeof="schema:Article">Wallgrün, J.O., Frommberger, L., Wolter, D., Dylla, F., Freksa, C.: Qualitative spatial representation and reasoning in the SparQ-toolbox. In: International Conference on Spatial Cognition. pp. 39–58. Springer (2006).</dd>
  <dt id="ref-20">[20]</dt>
  <dd resource="https://rdfostrich.github.io/article-jws2018-ostrich/" typeof="schema:Article">Taelman, R., Vander Sande, M., Van Herwegen, J., Mannens, E., Verborgh, R.: Triple Storage for Random-Access Versioned Querying of RDF Archives. Journal of Web Semantics. (2018).</dd>
  <dt id="ref-21">[21]</dt>
  <dd resource="#duan2011apples" typeof="schema:Article">Duan, S., Kementsietsidis, A., Srinivas, K., Udrea, O.: Apples and oranges: a comparison of RDF benchmarks and real RDF datasets. In: Proceedings of the 2011 ACM SIGMOD International Conference on Management of data. pp. 145–156 (2011).</dd>
  <dt id="ref-22">[22]</dt>
  <dd resource="https://comunica.github.io/Article-ISWC2018-Resource/" typeof="schema:Article">Taelman, R., Van Herwegen, J., Vander Sande, M., Verborgh, R.: Comunica: a Modular SPARQL Query Engine for the Web. In: Proceedings of the 17th International Semantic Web Conference (2018).</dd>
</dl>
</section>
</footer>

</div>



</body>
</html>
